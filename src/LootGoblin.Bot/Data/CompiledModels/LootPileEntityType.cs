// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using LootGoblin.Bot.Data.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace LootGoblin.Bot.Data.CompiledModels
{
    [EntityFrameworkInternal]
    public partial class LootPileEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "LootGoblin.Bot.Data.Entities.LootPile",
                typeof(LootPile),
                baseEntityType,
                propertyCount: 13,
                navigationCount: 1,
                foreignKeyCount: 1,
                unnamedIndexCount: 1,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: typeof(LootPile).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.SetGetter(
                int (LootPile entity) => LootPileUnsafeAccessors.Id(entity),
                bool (LootPile entity) => LootPileUnsafeAccessors.Id(entity) == 0,
                int (LootPile instance) => LootPileUnsafeAccessors.Id(instance),
                bool (LootPile instance) => LootPileUnsafeAccessors.Id(instance) == 0);
            id.SetSetter(
                (LootPile entity, int value) => LootPileUnsafeAccessors.Id(entity) = value);
            id.SetMaterializationSetter(
                (LootPile entity, int value) => LootPileUnsafeAccessors.Id(entity) = value);
            id.SetAccessors(
                int (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : (entry.FlaggedAsTemporary(0) && LootPileUnsafeAccessors.Id(((LootPile)(entry.Entity))) == 0 ? entry.ReadTemporaryValue<int>(0) : LootPileUnsafeAccessors.Id(((LootPile)(entry.Entity))))),
                int (InternalEntityEntry entry) => LootPileUnsafeAccessors.Id(((LootPile)(entry.Entity))),
                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
                int (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
                object (ValueBuffer valueBuffer) => valueBuffer[0]);
            id.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: -1,
                relationshipIndex: 0,
                storeGenerationIndex: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v));
            id.SetCurrentValueComparer(new EntryCurrentValueComparer<int>(id));
            id.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);

            var completedAt = runtimeEntityType.AddProperty(
                "CompletedAt",
                typeof(DateTimeOffset?),
                propertyInfo: typeof(LootPile).GetProperty("CompletedAt", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<CompletedAt>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            completedAt.SetGetter(
                DateTimeOffset? (LootPile entity) => LootPileUnsafeAccessors.CompletedAt(entity),
                bool (LootPile entity) => !(LootPileUnsafeAccessors.CompletedAt(entity).HasValue),
                DateTimeOffset? (LootPile instance) => LootPileUnsafeAccessors.CompletedAt(instance),
                bool (LootPile instance) => !(LootPileUnsafeAccessors.CompletedAt(instance).HasValue));
            completedAt.SetSetter(
                (LootPile entity, DateTimeOffset? value) => LootPileUnsafeAccessors.CompletedAt(entity) = value);
            completedAt.SetMaterializationSetter(
                (LootPile entity, DateTimeOffset? value) => LootPileUnsafeAccessors.CompletedAt(entity) = value);
            completedAt.SetAccessors(
                DateTimeOffset? (InternalEntityEntry entry) => LootPileUnsafeAccessors.CompletedAt(((LootPile)(entry.Entity))),
                DateTimeOffset? (InternalEntityEntry entry) => LootPileUnsafeAccessors.CompletedAt(((LootPile)(entry.Entity))),
                DateTimeOffset? (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTimeOffset?>(completedAt, 1),
                DateTimeOffset? (InternalEntityEntry entry) => entry.GetCurrentValue<DateTimeOffset?>(completedAt),
                object (ValueBuffer valueBuffer) => valueBuffer[1]);
            completedAt.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            completedAt.TypeMapping = SqlServerDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v));
            completedAt.SetComparer(new NullableValueComparer<DateTimeOffset>(completedAt.TypeMapping.Comparer));
            completedAt.SetKeyComparer(new NullableValueComparer<DateTimeOffset>(completedAt.TypeMapping.KeyComparer));
            completedAt.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var completedBy = runtimeEntityType.AddProperty(
                "CompletedBy",
                typeof(ulong?),
                propertyInfo: typeof(LootPile).GetProperty("CompletedBy", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<CompletedBy>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            completedBy.SetGetter(
                ulong? (LootPile entity) => LootPileUnsafeAccessors.CompletedBy(entity),
                bool (LootPile entity) => !(LootPileUnsafeAccessors.CompletedBy(entity).HasValue),
                ulong? (LootPile instance) => LootPileUnsafeAccessors.CompletedBy(instance),
                bool (LootPile instance) => !(LootPileUnsafeAccessors.CompletedBy(instance).HasValue));
            completedBy.SetSetter(
                (LootPile entity, ulong? value) => LootPileUnsafeAccessors.CompletedBy(entity) = value);
            completedBy.SetMaterializationSetter(
                (LootPile entity, ulong? value) => LootPileUnsafeAccessors.CompletedBy(entity) = value);
            completedBy.SetAccessors(
                ulong? (InternalEntityEntry entry) => LootPileUnsafeAccessors.CompletedBy(((LootPile)(entry.Entity))),
                ulong? (InternalEntityEntry entry) => LootPileUnsafeAccessors.CompletedBy(((LootPile)(entry.Entity))),
                ulong? (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong?>(completedBy, 2),
                ulong? (InternalEntityEntry entry) => entry.GetCurrentValue<ulong?>(completedBy),
                object (ValueBuffer valueBuffer) => valueBuffer[2]);
            completedBy.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            completedBy.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    decimal (ulong v) => ((decimal)(v)),
                    ulong (decimal v) => ((ulong)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v)))));
            completedBy.SetComparer(new NullableValueComparer<ulong>(completedBy.TypeMapping.Comparer));
            completedBy.SetKeyComparer(new NullableValueComparer<ulong>(completedBy.TypeMapping.KeyComparer));
            completedBy.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var createdAt = runtimeEntityType.AddProperty(
                "CreatedAt",
                typeof(DateTimeOffset),
                propertyInfo: typeof(LootPile).GetProperty("CreatedAt", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<CreatedAt>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTimeOffset(new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified), new TimeSpan(0, 0, 0, 0, 0)));
            createdAt.SetGetter(
                DateTimeOffset (LootPile entity) => LootPileUnsafeAccessors.CreatedAt(entity),
                bool (LootPile entity) => LootPileUnsafeAccessors.CreatedAt(entity).EqualsExact(default(DateTimeOffset)),
                DateTimeOffset (LootPile instance) => LootPileUnsafeAccessors.CreatedAt(instance),
                bool (LootPile instance) => LootPileUnsafeAccessors.CreatedAt(instance).EqualsExact(default(DateTimeOffset)));
            createdAt.SetSetter(
                (LootPile entity, DateTimeOffset value) => LootPileUnsafeAccessors.CreatedAt(entity) = value);
            createdAt.SetMaterializationSetter(
                (LootPile entity, DateTimeOffset value) => LootPileUnsafeAccessors.CreatedAt(entity) = value);
            createdAt.SetAccessors(
                DateTimeOffset (InternalEntityEntry entry) => LootPileUnsafeAccessors.CreatedAt(((LootPile)(entry.Entity))),
                DateTimeOffset (InternalEntityEntry entry) => LootPileUnsafeAccessors.CreatedAt(((LootPile)(entry.Entity))),
                DateTimeOffset (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(createdAt, 3),
                DateTimeOffset (InternalEntityEntry entry) => entry.GetCurrentValue<DateTimeOffset>(createdAt),
                object (ValueBuffer valueBuffer) => valueBuffer[3]);
            createdAt.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            createdAt.TypeMapping = SqlServerDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v));
            createdAt.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var createdBy = runtimeEntityType.AddProperty(
                "CreatedBy",
                typeof(ulong),
                propertyInfo: typeof(LootPile).GetProperty("CreatedBy", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<CreatedBy>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            createdBy.SetGetter(
                ulong (LootPile entity) => LootPileUnsafeAccessors.CreatedBy(entity),
                bool (LootPile entity) => LootPileUnsafeAccessors.CreatedBy(entity) == 0UL,
                ulong (LootPile instance) => LootPileUnsafeAccessors.CreatedBy(instance),
                bool (LootPile instance) => LootPileUnsafeAccessors.CreatedBy(instance) == 0UL);
            createdBy.SetSetter(
                (LootPile entity, ulong value) => LootPileUnsafeAccessors.CreatedBy(entity) = value);
            createdBy.SetMaterializationSetter(
                (LootPile entity, ulong value) => LootPileUnsafeAccessors.CreatedBy(entity) = value);
            createdBy.SetAccessors(
                ulong (InternalEntityEntry entry) => LootPileUnsafeAccessors.CreatedBy(((LootPile)(entry.Entity))),
                ulong (InternalEntityEntry entry) => LootPileUnsafeAccessors.CreatedBy(((LootPile)(entry.Entity))),
                ulong (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong>(createdBy, 4),
                ulong (InternalEntityEntry entry) => entry.GetCurrentValue<ulong>(createdBy),
                object (ValueBuffer valueBuffer) => valueBuffer[4]);
            createdBy.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            createdBy.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    decimal (ulong v) => ((decimal)(v)),
                    ulong (decimal v) => ((ulong)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v)))));
            createdBy.SetSentinelFromProviderValue(0m);
            createdBy.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var currentStatus = runtimeEntityType.AddProperty(
                "CurrentStatus",
                typeof(LootStatus),
                propertyInfo: typeof(LootPile).GetProperty("CurrentStatus", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<CurrentStatus>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            currentStatus.SetGetter(
                LootStatus (LootPile entity) => LootPileUnsafeAccessors.CurrentStatus(entity),
                bool (LootPile entity) => object.Equals(((object)(LootPileUnsafeAccessors.CurrentStatus(entity))), ((object)(LootStatus.Created))),
                LootStatus (LootPile instance) => LootPileUnsafeAccessors.CurrentStatus(instance),
                bool (LootPile instance) => object.Equals(((object)(LootPileUnsafeAccessors.CurrentStatus(instance))), ((object)(LootStatus.Created))));
            currentStatus.SetSetter(
                (LootPile entity, LootStatus value) => LootPileUnsafeAccessors.CurrentStatus(entity) = value);
            currentStatus.SetMaterializationSetter(
                (LootPile entity, LootStatus value) => LootPileUnsafeAccessors.CurrentStatus(entity) = value);
            currentStatus.SetAccessors(
                LootStatus (InternalEntityEntry entry) => LootPileUnsafeAccessors.CurrentStatus(((LootPile)(entry.Entity))),
                LootStatus (InternalEntityEntry entry) => LootPileUnsafeAccessors.CurrentStatus(((LootPile)(entry.Entity))),
                LootStatus (InternalEntityEntry entry) => entry.ReadOriginalValue<LootStatus>(currentStatus, 5),
                LootStatus (InternalEntityEntry entry) => entry.GetCurrentValue<LootStatus>(currentStatus),
                object (ValueBuffer valueBuffer) => valueBuffer[5]);
            currentStatus.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            currentStatus.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<LootStatus>(
                    bool (LootStatus v1, LootStatus v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (LootStatus v) => ((object)v).GetHashCode(),
                    LootStatus (LootStatus v) => v),
                keyComparer: new ValueComparer<LootStatus>(
                    bool (LootStatus v1, LootStatus v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (LootStatus v) => ((object)v).GetHashCode(),
                    LootStatus (LootStatus v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                converter: new ValueConverter<LootStatus, byte>(
                    byte (LootStatus value) => ((byte)(value)),
                    LootStatus (byte value) => ((LootStatus)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<LootStatus, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<LootStatus, byte>(
                        byte (LootStatus value) => ((byte)(value)),
                        LootStatus (byte value) => ((LootStatus)(value)))));
            currentStatus.SetSentinelFromProviderValue((byte)0);
            currentStatus.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var description = runtimeEntityType.AddProperty(
                "Description",
                typeof(string),
                propertyInfo: typeof(LootPile).GetProperty("Description", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<Description>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 2048);
            description.SetGetter(
                string (LootPile entity) => LootPileUnsafeAccessors.Description(entity),
                bool (LootPile entity) => LootPileUnsafeAccessors.Description(entity) == null,
                string (LootPile instance) => LootPileUnsafeAccessors.Description(instance),
                bool (LootPile instance) => LootPileUnsafeAccessors.Description(instance) == null);
            description.SetSetter(
                (LootPile entity, string value) => LootPileUnsafeAccessors.Description(entity) = value);
            description.SetMaterializationSetter(
                (LootPile entity, string value) => LootPileUnsafeAccessors.Description(entity) = value);
            description.SetAccessors(
                string (InternalEntityEntry entry) => LootPileUnsafeAccessors.Description(((LootPile)(entry.Entity))),
                string (InternalEntityEntry entry) => LootPileUnsafeAccessors.Description(((LootPile)(entry.Entity))),
                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(description, 6),
                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(description),
                object (ValueBuffer valueBuffer) => valueBuffer[6]);
            description.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            description.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(2048)",
                    size: 2048,
                    unicode: true,
                    dbType: System.Data.DbType.String));
            description.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var eventId = runtimeEntityType.AddProperty(
                "EventId",
                typeof(int),
                propertyInfo: typeof(LootPile).GetProperty("EventId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<EventId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            eventId.SetGetter(
                int (LootPile entity) => LootPileUnsafeAccessors.EventId(entity),
                bool (LootPile entity) => LootPileUnsafeAccessors.EventId(entity) == 0,
                int (LootPile instance) => LootPileUnsafeAccessors.EventId(instance),
                bool (LootPile instance) => LootPileUnsafeAccessors.EventId(instance) == 0);
            eventId.SetSetter(
                (LootPile entity, int value) => LootPileUnsafeAccessors.EventId(entity) = value);
            eventId.SetMaterializationSetter(
                (LootPile entity, int value) => LootPileUnsafeAccessors.EventId(entity) = value);
            eventId.SetAccessors(
                int (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(7) ? entry.ReadStoreGeneratedValue<int>(1) : (entry.FlaggedAsTemporary(7) && LootPileUnsafeAccessors.EventId(((LootPile)(entry.Entity))) == 0 ? entry.ReadTemporaryValue<int>(1) : LootPileUnsafeAccessors.EventId(((LootPile)(entry.Entity))))),
                int (InternalEntityEntry entry) => LootPileUnsafeAccessors.EventId(((LootPile)(entry.Entity))),
                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(eventId, 7),
                int (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(eventId, 1),
                object (ValueBuffer valueBuffer) => valueBuffer[7]);
            eventId.SetPropertyIndexes(
                index: 7,
                originalValueIndex: 7,
                shadowIndex: -1,
                relationshipIndex: 1,
                storeGenerationIndex: 1);
            eventId.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v));
            eventId.SetCurrentValueComparer(new EntryCurrentValueComparer<int>(eventId));
            eventId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var lootType = runtimeEntityType.AddProperty(
                "LootType",
                typeof(LootType),
                propertyInfo: typeof(LootPile).GetProperty("LootType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<LootType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            lootType.SetGetter(
                LootType (LootPile entity) => LootPileUnsafeAccessors.LootType(entity),
                bool (LootPile entity) => object.Equals(((object)(LootPileUnsafeAccessors.LootType(entity))), ((object)(LootType.Restricted))),
                LootType (LootPile instance) => LootPileUnsafeAccessors.LootType(instance),
                bool (LootPile instance) => object.Equals(((object)(LootPileUnsafeAccessors.LootType(instance))), ((object)(LootType.Restricted))));
            lootType.SetSetter(
                (LootPile entity, LootType value) => LootPileUnsafeAccessors.LootType(entity) = value);
            lootType.SetMaterializationSetter(
                (LootPile entity, LootType value) => LootPileUnsafeAccessors.LootType(entity) = value);
            lootType.SetAccessors(
                LootType (InternalEntityEntry entry) => LootPileUnsafeAccessors.LootType(((LootPile)(entry.Entity))),
                LootType (InternalEntityEntry entry) => LootPileUnsafeAccessors.LootType(((LootPile)(entry.Entity))),
                LootType (InternalEntityEntry entry) => entry.ReadOriginalValue<LootType>(lootType, 8),
                LootType (InternalEntityEntry entry) => entry.GetCurrentValue<LootType>(lootType),
                object (ValueBuffer valueBuffer) => valueBuffer[8]);
            lootType.SetPropertyIndexes(
                index: 8,
                originalValueIndex: 8,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            lootType.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<LootType>(
                    bool (LootType v1, LootType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (LootType v) => ((object)v).GetHashCode(),
                    LootType (LootType v) => v),
                keyComparer: new ValueComparer<LootType>(
                    bool (LootType v1, LootType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (LootType v) => ((object)v).GetHashCode(),
                    LootType (LootType v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                converter: new ValueConverter<LootType, byte>(
                    byte (LootType value) => ((byte)(value)),
                    LootType (byte value) => ((LootType)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<LootType, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<LootType, byte>(
                        byte (LootType value) => ((byte)(value)),
                        LootType (byte value) => ((LootType)(value)))));
            lootType.SetSentinelFromProviderValue((byte)0);
            lootType.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var messageId = runtimeEntityType.AddProperty(
                "MessageId",
                typeof(ulong?),
                propertyInfo: typeof(LootPile).GetProperty("MessageId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<MessageId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            messageId.SetGetter(
                ulong? (LootPile entity) => LootPileUnsafeAccessors.MessageId(entity),
                bool (LootPile entity) => !(LootPileUnsafeAccessors.MessageId(entity).HasValue),
                ulong? (LootPile instance) => LootPileUnsafeAccessors.MessageId(instance),
                bool (LootPile instance) => !(LootPileUnsafeAccessors.MessageId(instance).HasValue));
            messageId.SetSetter(
                (LootPile entity, ulong? value) => LootPileUnsafeAccessors.MessageId(entity) = value);
            messageId.SetMaterializationSetter(
                (LootPile entity, ulong? value) => LootPileUnsafeAccessors.MessageId(entity) = value);
            messageId.SetAccessors(
                ulong? (InternalEntityEntry entry) => LootPileUnsafeAccessors.MessageId(((LootPile)(entry.Entity))),
                ulong? (InternalEntityEntry entry) => LootPileUnsafeAccessors.MessageId(((LootPile)(entry.Entity))),
                ulong? (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong?>(messageId, 9),
                ulong? (InternalEntityEntry entry) => entry.GetCurrentValue<ulong?>(messageId),
                object (ValueBuffer valueBuffer) => valueBuffer[9]);
            messageId.SetPropertyIndexes(
                index: 9,
                originalValueIndex: 9,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            messageId.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    decimal (ulong v) => ((decimal)(v)),
                    ulong (decimal v) => ((ulong)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v)))));
            messageId.SetComparer(new NullableValueComparer<ulong>(messageId.TypeMapping.Comparer));
            messageId.SetKeyComparer(new NullableValueComparer<ulong>(messageId.TypeMapping.KeyComparer));
            messageId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var name = runtimeEntityType.AddProperty(
                "Name",
                typeof(string),
                propertyInfo: typeof(LootPile).GetProperty("Name", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<Name>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 256);
            name.SetGetter(
                string (LootPile entity) => LootPileUnsafeAccessors.Name(entity),
                bool (LootPile entity) => LootPileUnsafeAccessors.Name(entity) == null,
                string (LootPile instance) => LootPileUnsafeAccessors.Name(instance),
                bool (LootPile instance) => LootPileUnsafeAccessors.Name(instance) == null);
            name.SetSetter(
                (LootPile entity, string value) => LootPileUnsafeAccessors.Name(entity) = value);
            name.SetMaterializationSetter(
                (LootPile entity, string value) => LootPileUnsafeAccessors.Name(entity) = value);
            name.SetAccessors(
                string (InternalEntityEntry entry) => LootPileUnsafeAccessors.Name(((LootPile)(entry.Entity))),
                string (InternalEntityEntry entry) => LootPileUnsafeAccessors.Name(((LootPile)(entry.Entity))),
                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(name, 10),
                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(name),
                object (ValueBuffer valueBuffer) => valueBuffer[10]);
            name.SetPropertyIndexes(
                index: 10,
                originalValueIndex: 10,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            name.TypeMapping = SqlServerStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "nvarchar(256)",
                    size: 256,
                    unicode: true,
                    dbType: System.Data.DbType.String));
            name.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var originChannelId = runtimeEntityType.AddProperty(
                "OriginChannelId",
                typeof(ulong?),
                propertyInfo: typeof(LootPile).GetProperty("OriginChannelId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<OriginChannelId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            originChannelId.SetGetter(
                ulong? (LootPile entity) => LootPileUnsafeAccessors.OriginChannelId(entity),
                bool (LootPile entity) => !(LootPileUnsafeAccessors.OriginChannelId(entity).HasValue),
                ulong? (LootPile instance) => LootPileUnsafeAccessors.OriginChannelId(instance),
                bool (LootPile instance) => !(LootPileUnsafeAccessors.OriginChannelId(instance).HasValue));
            originChannelId.SetSetter(
                (LootPile entity, ulong? value) => LootPileUnsafeAccessors.OriginChannelId(entity) = value);
            originChannelId.SetMaterializationSetter(
                (LootPile entity, ulong? value) => LootPileUnsafeAccessors.OriginChannelId(entity) = value);
            originChannelId.SetAccessors(
                ulong? (InternalEntityEntry entry) => LootPileUnsafeAccessors.OriginChannelId(((LootPile)(entry.Entity))),
                ulong? (InternalEntityEntry entry) => LootPileUnsafeAccessors.OriginChannelId(((LootPile)(entry.Entity))),
                ulong? (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong?>(originChannelId, 11),
                ulong? (InternalEntityEntry entry) => entry.GetCurrentValue<ulong?>(originChannelId),
                object (ValueBuffer valueBuffer) => valueBuffer[11]);
            originChannelId.SetPropertyIndexes(
                index: 11,
                originalValueIndex: 11,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            originChannelId.TypeMapping = SqlServerDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                keyComparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    bool (decimal v1, decimal v2) => v1 == v2,
                    int (decimal v) => ((object)v).GetHashCode(),
                    decimal (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "decimal(20,0)",
                    precision: 20,
                    scale: 0),
                converter: new ValueConverter<ulong, decimal>(
                    decimal (ulong v) => ((decimal)(v)),
                    ulong (decimal v) => ((ulong)(v))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ulong, decimal>(
                    JsonDecimalReaderWriter.Instance,
                    new ValueConverter<ulong, decimal>(
                        decimal (ulong v) => ((decimal)(v)),
                        ulong (decimal v) => ((ulong)(v)))));
            originChannelId.SetComparer(new NullableValueComparer<ulong>(originChannelId.TypeMapping.Comparer));
            originChannelId.SetKeyComparer(new NullableValueComparer<ulong>(originChannelId.TypeMapping.KeyComparer));
            originChannelId.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var rollType = runtimeEntityType.AddProperty(
                "RollType",
                typeof(LootRollType),
                propertyInfo: typeof(LootPile).GetProperty("RollType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<RollType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            rollType.SetGetter(
                LootRollType (LootPile entity) => LootPileUnsafeAccessors.RollType(entity),
                bool (LootPile entity) => object.Equals(((object)(LootPileUnsafeAccessors.RollType(entity))), ((object)(LootRollType.Roll))),
                LootRollType (LootPile instance) => LootPileUnsafeAccessors.RollType(instance),
                bool (LootPile instance) => object.Equals(((object)(LootPileUnsafeAccessors.RollType(instance))), ((object)(LootRollType.Roll))));
            rollType.SetSetter(
                (LootPile entity, LootRollType value) => LootPileUnsafeAccessors.RollType(entity) = value);
            rollType.SetMaterializationSetter(
                (LootPile entity, LootRollType value) => LootPileUnsafeAccessors.RollType(entity) = value);
            rollType.SetAccessors(
                LootRollType (InternalEntityEntry entry) => LootPileUnsafeAccessors.RollType(((LootPile)(entry.Entity))),
                LootRollType (InternalEntityEntry entry) => LootPileUnsafeAccessors.RollType(((LootPile)(entry.Entity))),
                LootRollType (InternalEntityEntry entry) => entry.ReadOriginalValue<LootRollType>(rollType, 12),
                LootRollType (InternalEntityEntry entry) => entry.GetCurrentValue<LootRollType>(rollType),
                object (ValueBuffer valueBuffer) => valueBuffer[12]);
            rollType.SetPropertyIndexes(
                index: 12,
                originalValueIndex: 12,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            rollType.TypeMapping = SqlServerByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<LootRollType>(
                    bool (LootRollType v1, LootRollType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (LootRollType v) => ((object)v).GetHashCode(),
                    LootRollType (LootRollType v) => v),
                keyComparer: new ValueComparer<LootRollType>(
                    bool (LootRollType v1, LootRollType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (LootRollType v) => ((object)v).GetHashCode(),
                    LootRollType (LootRollType v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                converter: new ValueConverter<LootRollType, byte>(
                    byte (LootRollType value) => ((byte)(value)),
                    LootRollType (byte value) => ((LootRollType)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<LootRollType, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<LootRollType, byte>(
                        byte (LootRollType value) => ((byte)(value)),
                        LootRollType (byte value) => ((LootRollType)(value)))));
            rollType.SetSentinelFromProviderValue((byte)0);
            rollType.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { eventId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("EventId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            var @event = declaringEntityType.AddNavigation("Event",
                runtimeForeignKey,
                onDependent: true,
                typeof(GuildEvent),
                propertyInfo: typeof(LootPile).GetProperty("Event", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(LootPile).GetField("<Event>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            @event.SetGetter(
                GuildEvent (LootPile entity) => LootPileUnsafeAccessors.Event(entity),
                bool (LootPile entity) => LootPileUnsafeAccessors.Event(entity) == null,
                GuildEvent (LootPile instance) => LootPileUnsafeAccessors.Event(instance),
                bool (LootPile instance) => LootPileUnsafeAccessors.Event(instance) == null);
            @event.SetSetter(
                (LootPile entity, GuildEvent value) => LootPileUnsafeAccessors.Event(entity) = value);
            @event.SetMaterializationSetter(
                (LootPile entity, GuildEvent value) => LootPileUnsafeAccessors.Event(entity) = value);
            @event.SetAccessors(
                GuildEvent (InternalEntityEntry entry) => LootPileUnsafeAccessors.Event(((LootPile)(entry.Entity))),
                GuildEvent (InternalEntityEntry entry) => LootPileUnsafeAccessors.Event(((LootPile)(entry.Entity))),
                null,
                GuildEvent (InternalEntityEntry entry) => entry.GetCurrentValue<GuildEvent>(@event),
                null);
            @event.SetPropertyIndexes(
                index: 0,
                originalValueIndex: -1,
                shadowIndex: -1,
                relationshipIndex: 2,
                storeGenerationIndex: -1);
            var lootPiles = principalEntityType.AddNavigation("LootPiles",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<LootPile>),
                propertyInfo: typeof(GuildEvent).GetProperty("LootPiles", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(GuildEvent).GetField("<LootPiles>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            lootPiles.SetGetter(
                ICollection<LootPile> (GuildEvent entity) => GuildEventUnsafeAccessors.LootPiles(entity),
                bool (GuildEvent entity) => GuildEventUnsafeAccessors.LootPiles(entity) == null,
                ICollection<LootPile> (GuildEvent instance) => GuildEventUnsafeAccessors.LootPiles(instance),
                bool (GuildEvent instance) => GuildEventUnsafeAccessors.LootPiles(instance) == null);
            lootPiles.SetSetter(
                (GuildEvent entity, ICollection<LootPile> value) => GuildEventUnsafeAccessors.LootPiles(entity) = value);
            lootPiles.SetMaterializationSetter(
                (GuildEvent entity, ICollection<LootPile> value) => GuildEventUnsafeAccessors.LootPiles(entity) = value);
            lootPiles.SetAccessors(
                ICollection<LootPile> (InternalEntityEntry entry) => GuildEventUnsafeAccessors.LootPiles(((GuildEvent)(entry.Entity))),
                ICollection<LootPile> (InternalEntityEntry entry) => GuildEventUnsafeAccessors.LootPiles(((GuildEvent)(entry.Entity))),
                null,
                ICollection<LootPile> (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<LootPile>>(lootPiles),
                null);
            lootPiles.SetPropertyIndexes(
                index: 1,
                originalValueIndex: -1,
                shadowIndex: -1,
                relationshipIndex: 2,
                storeGenerationIndex: -1);
            lootPiles.SetCollectionAccessor<GuildEvent, ICollection<LootPile>, LootPile>(
                ICollection<LootPile> (GuildEvent entity) => GuildEventUnsafeAccessors.LootPiles(entity),
                (GuildEvent entity, ICollection<LootPile> collection) => GuildEventUnsafeAccessors.LootPiles(entity) = ((ICollection<LootPile>)(collection)),
                (GuildEvent entity, ICollection<LootPile> collection) => GuildEventUnsafeAccessors.LootPiles(entity) = ((ICollection<LootPile>)(collection)),
                ICollection<LootPile> (GuildEvent entity, Action<GuildEvent, ICollection<LootPile>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<GuildEvent, ICollection<LootPile>, LootPile>(entity, setter),
                ICollection<LootPile> () => ((ICollection<LootPile>)(((ICollection<LootPile>)(new HashSet<LootPile>(ReferenceEqualityComparer.Instance))))));
            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var id = runtimeEntityType.FindProperty("Id");
            var completedAt = runtimeEntityType.FindProperty("CompletedAt");
            var completedBy = runtimeEntityType.FindProperty("CompletedBy");
            var createdAt = runtimeEntityType.FindProperty("CreatedAt");
            var createdBy = runtimeEntityType.FindProperty("CreatedBy");
            var currentStatus = runtimeEntityType.FindProperty("CurrentStatus");
            var description = runtimeEntityType.FindProperty("Description");
            var eventId = runtimeEntityType.FindProperty("EventId");
            var lootType = runtimeEntityType.FindProperty("LootType");
            var messageId = runtimeEntityType.FindProperty("MessageId");
            var name = runtimeEntityType.FindProperty("Name");
            var originChannelId = runtimeEntityType.FindProperty("OriginChannelId");
            var rollType = runtimeEntityType.FindProperty("RollType");
            var key = runtimeEntityType.FindKey(new[] { id });
            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
            var @event = runtimeEntityType.FindNavigation("Event");
            runtimeEntityType.SetOriginalValuesFactory(
                ISnapshot (InternalEntityEntry source) =>
                {
                    var entity = ((LootPile)(source.Entity));
                    return ((ISnapshot)(new Snapshot<int, DateTimeOffset?, ulong?, DateTimeOffset, ulong, LootStatus, string, int, LootType, ulong?, string, ulong?, LootRollType>(((ValueComparer<int>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(id)), (source.GetCurrentValue<DateTimeOffset?>(completedAt) == null ? null : ((ValueComparer<DateTimeOffset?>)(((IProperty)completedAt).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset?>(completedAt))), (source.GetCurrentValue<ulong?>(completedBy) == null ? null : ((ValueComparer<ulong?>)(((IProperty)completedBy).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong?>(completedBy))), ((ValueComparer<DateTimeOffset>)(((IProperty)createdAt).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(createdAt)), ((ValueComparer<ulong>)(((IProperty)createdBy).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong>(createdBy)), ((ValueComparer<LootStatus>)(((IProperty)currentStatus).GetValueComparer())).Snapshot(source.GetCurrentValue<LootStatus>(currentStatus)), (source.GetCurrentValue<string>(description) == null ? null : ((ValueComparer<string>)(((IProperty)description).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(description))), ((ValueComparer<int>)(((IProperty)eventId).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(eventId)), ((ValueComparer<LootType>)(((IProperty)lootType).GetValueComparer())).Snapshot(source.GetCurrentValue<LootType>(lootType)), (source.GetCurrentValue<ulong?>(messageId) == null ? null : ((ValueComparer<ulong?>)(((IProperty)messageId).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong?>(messageId))), (source.GetCurrentValue<string>(name) == null ? null : ((ValueComparer<string>)(((IProperty)name).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(name))), (source.GetCurrentValue<ulong?>(originChannelId) == null ? null : ((ValueComparer<ulong?>)(((IProperty)originChannelId).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong?>(originChannelId))), ((ValueComparer<LootRollType>)(((IProperty)rollType).GetValueComparer())).Snapshot(source.GetCurrentValue<LootRollType>(rollType)))));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                ISnapshot () => ((ISnapshot)(new Snapshot<int, int>(((ValueComparer<int>)(((IProperty)id).GetValueComparer())).Snapshot(default(int)), ((ValueComparer<int>)(((IProperty)eventId).GetValueComparer())).Snapshot(default(int))))));
            runtimeEntityType.SetTemporaryValuesFactory(
                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<int, int>(default(int), default(int)))));
            runtimeEntityType.SetShadowValuesFactory(
                ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
            runtimeEntityType.SetEmptyShadowValuesFactory(
                ISnapshot () => Snapshot.Empty);
            runtimeEntityType.SetRelationshipSnapshotFactory(
                ISnapshot (InternalEntityEntry source) =>
                {
                    var entity = ((LootPile)(source.Entity));
                    return ((ISnapshot)(new Snapshot<int, int, object>(((ValueComparer<int>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<int>(id)), ((ValueComparer<int>)(((IProperty)eventId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<int>(eventId)), LootPileUnsafeAccessors.Event(entity))));
                });
            runtimeEntityType.Counts = new PropertyCounts(
                propertyCount: 13,
                navigationCount: 1,
                complexPropertyCount: 0,
                originalValueCount: 13,
                shadowCount: 0,
                relationshipCount: 3,
                storeGeneratedCount: 2);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "LootPiles");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
